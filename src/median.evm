// Median Implementation in EVM bytecode
//
//       Storage layout
// slot                 name
// --------------------------------------
// 0                     wards
// 1                     val
// 2                     age
// 3                     bar
// keccak(address,4)     orcl
// keccak(address,5)     bud
// keccak(uint8,6)       slot
//





# constructor

61 -> end
61 : start
60 00
39
61 -> end
60 00
f3





# start

60 00
35
60 e0
1c
80
63 89 bb b8 b2         // poke(uint256[],uint256[],uint8[],bytes32[],bytes32[])
14
61 -> poke
57
63 35 2d 3f ba         // setBar(uint256)
14
61 -> setBar
57
60 00
60 00
fd



# poke
5b

// copy calldata to memory
60 04
36
03
60 04
60 00
37

// obtain bar
60 03                  // bar
54

// ensure bar is greater than zero
80
15
61 -> bar-too-low
57

// ensure arrays have bar length
60 00
# bar-loop
5b
81
81
51
51
14
15
61 -> bar-too-low
57
60 20
01
80
60 a0
11
61 -> bar-loop
57
50

// multiply bar by 0x20 and add 0x20
60 20
02
60 20
01

// get free memory position
80
60 02
01
60 06
02
90

// loop over arrays
60 20                  // stack: [free, 0x20*bar+0x20, 0x20*i+0x20] <-
# array-loop
5b

// loop over args
60 00
90
60 00                  // stack: [free, bar, gap, i, j]
# arg-loop
5b
81
81
51
01
51
85
82
01
84
01
52

// set gap
80
60 20
14
15
61 -> iterate-arg-loop
57
91
60 80
01
91

# iterate-arg-loop
5b
60 20
01
80
60 a0
11
61 -> arg-loop
57
50
90
50

// log (remove)
61 01 20
83
a0

// iterate
60 20
01
81
81
14
15
61 -> array-loop
57
50
50

00



# setBar
5b
60 04
35
60 03
55
00



# bar-too-low
5b
7f 4d 65 64 69 61 6e 2f 62 61 72 2d 74 6f 6f 2d 6c 6f 77 00 00 00 00 00 00 00 00 00 00 00 00 00 00
60 00
52
60 20
60 00
fd





# end